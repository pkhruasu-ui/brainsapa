describe("resolve",function(){var e,t;beforeEach(module("ui.router.util")),beforeEach(module(function(
e){e.factory("Foo",function(){return"Working"})})),beforeEach(inject(function(n,r){e=n,t=r.flush})),describe
(".resolve()",function(){it("calls injectable functions and returns a promise",function(){var n=jasmine
.createSpy("fun").andReturn(42),r=e.resolve({fun:["$resolve",n]});expect(r).not.toBeResolved(),t(),expect
(resolvedValue(r)).toEqual({fun:42}),expect(n).toHaveBeenCalled(),expect(n.callCount).toBe(1),expect(
n.mostRecentCall.args.length).toBe(1),expect(n.mostRecentCall.args[0]).toBe(e)}),it("resolves promises returned from the functions"
,inject(function(n){var r=n.defer(),i=jasmine.createSpy("fun").andReturn(r.promise),s=e.resolve({fun:
["$resolve",i]});t(),expect(s).not.toBeResolved(),r.resolve("async"),t(),expect(resolvedValue(s)).toEqual
({fun:"async"})})),it("resolves dependencies between functions",function(){var n=jasmine.createSpy("a"
),r=jasmine.createSpy("b").andReturn("bb"),i=e.resolve({a:["b",n],b:[r]});t(),expect(n).toHaveBeenCalled
(),expect(n.mostRecentCall.args).toEqual(["bb"]),expect(r).toHaveBeenCalled()}),it("resolves dependencies between functions that return promises"
,inject(function(n){var r=n.defer(),i=jasmine.createSpy("a").andReturn(r.promise),s=n.defer(),o=jasmine
.createSpy("b").andReturn(s.promise),u=n.defer(),a=jasmine.createSpy("c").andReturn(u.promise),f=e.resolve
({a:["b","c",i],b:["c",o],c:[a]});t(),expect(f).not.toBeResolved(),expect(i).not.toHaveBeenCalled(),expect
(o).not.toHaveBeenCalled(),expect(a).toHaveBeenCalled(),u.resolve("cc"),t(),expect(f).not.toBeResolved
(),expect(i).not.toHaveBeenCalled(),expect(o).toHaveBeenCalled(),expect(o.mostRecentCall.args).toEqual
(["cc"]),s.resolve("bb"),t(),expect(f).not.toBeResolved(),expect(i).toHaveBeenCalled(),expect(i.mostRecentCall
.args).toEqual(["bb","cc"]),r.resolve("aa"),t(),expect(resolvedValue(f)).toEqual({a:"aa",b:"bb",c:"cc"
}),expect(i.callCount).toBe(1),expect(o.callCount).toBe(1),expect(a.callCount).toBe(1)})),it("refuses cyclic dependencies"
,function(){var t=jasmine.createSpy("a"),n=jasmine.createSpy("b");expect(caught(function(){e.resolve(
{a:["b",t],b:["a",n]})})).toMatch(/cyclic/i),expect(t).not.toHaveBeenCalled(),expect(n).not.toHaveBeenCalled
()}),it("allows a function to depend on an injector value of the same name",function(){var n=e.resolve
({$resolve:function(t){return t===e}});t(),expect(resolvedValue(n)).toEqual({$resolve:!0})}),it("allows locals to be passed that override the injector"
,function(){var n=jasmine.createSpy("fun");e.resolve({fun:["$resolve",n]},{$resolve:42}),t(),expect(n
).toHaveBeenCalled(),expect(n.mostRecentCall.args[0]).toBe(42)}),it("does not call injectables overridden by a local"
,function(){var n=jasmine.createSpy("fun").andReturn("function"),r=e.resolve({fun:[n]},{fun:"local"})
;t(),expect(n).not.toHaveBeenCalled(),expect(resolvedValue(r)).toEqual({fun:"local"})}),it("includes locals in the returned values"
,function(){var n={foo:"hi",bar:"mom"},r=e.resolve({},n);t(),expect(resolvedValue(r)).toEqual(n)}),it
("allows inheritance from a parent resolve()",function(){var n=e.resolve({fun:function(){return!0}}),
r=e.resolve({games:function(){return!0}},n);t(),expect(n).toBeResolved(),expect(resolvedValue(r)).toEqual
({fun:!0,games:!0})}),it("only accepts promises from $resolve as parent",inject(function(t){expect(caught
(function(){e.resolve({},null,t.defer().promise)})).toMatch(/\$resolve\.resolve/)})),it("resolves dependencies from a parent resolve()"
,function(){var n=e.resolve({a:[function(){return"aa"}]}),r=jasmine.createSpy("b"),i=e.resolve({b:["a"
,r]},n);t(),expect(r).toHaveBeenCalled(),expect(r.mostRecentCall.args).toEqual(["aa"])}),it("allow access to ancestor resolves in descendent resolve blocks"
,inject(function(n){var r=n.defer(),i=jasmine.createSpy("gInjectable").andReturn(r.promise),s=n.defer
(),o=jasmine.createSpy("pInjectable").andReturn(s.promise),u=e.resolve({gP:[i]},u);r.resolve("grandparent"
),t();var a=jasmine.createSpy("s"),f=e.resolve({p:[o]},u),l=e.resolve({c:["p","gP",a]},f);s.resolve("parent"
),t(),expect(a).toHaveBeenCalled(),expect(a.mostRecentCall.args).toEqual(["parent","grandparent"])}))
,it("allow parent resolve to override grandparent resolve",inject(function(n){var r=n.defer(),i=jasmine
.createSpy("gInjectable").andReturn(r.promise),s=e.resolve({item:[function(){return"grandparent"}]},s
);r.resolve("grandparent"),t();var o=e.resolve({item:[function(){return"parent"}]},{},s),u=jasmine.createSpy
("s"),a=e.resolve({c:[u]},{},o);t(),expect(u).toHaveBeenCalled(),expect(a.$$values.item).toBe("parent"
)})),it("allows a function to override a parent value of the same name",function(){var n=e.resolve({b
:function(){return"B"}}),r=e.resolve({a:function(e){return"a:"+e},b:function(e){return"("+e+")"},c:function(
e){return"c:"+e}},n);t(),expect(resolvedValue(r)).toEqual({a:"a:(B)",b:"(B)",c:"c:(B)"})}),it("allows a function to override a parent value of the same name with a promise"
,inject(function(n){var r=e.resolve({b:function(){return"B"}}),i,s=n.defer(),o=e.resolve({a:function(
e){return"a:"+e},b:function(e){return i=e,s.promise},c:function(e){return"c:"+e}},r);t(),s.resolve("("+
i+")"),t(),expect(resolvedValue(o)).toEqual({a:"a:(B)",b:"(B)",c:"c:(B)"})})),it("it only resolves after the parent resolves"
,inject(function(n){var r=n.defer(),i=jasmine.createSpy("b").andReturn(r.promise),s=n.defer(),o=jasmine
.createSpy("c").andReturn(s.promise),u=e.resolve({c:[o]}),a=e.resolve({b:[i]},u);r.resolve("bbb"),t()
,expect(u).not.toBeResolved(),expect(a).not.toBeResolved(),s.resolve("ccc"),t(),expect(resolvedValue(
u)).toEqual({c:"ccc"}),expect(resolvedValue(a)).toEqual({b:"bbb",c:"ccc"})})),it("invokes functions as soon as possible"
,inject(function(n){var r=n.defer(),i=jasmine.createSpy("a").andReturn(r.promise),s=n.defer(),o=jasmine
.createSpy("b").andReturn(s.promise),u=n.defer(),a=jasmine.createSpy("c").andReturn(u.promise),f=e.resolve
({c:[a]}),l=e.resolve({a:[i],b:["c",o]},f);expect(a).toHaveBeenCalled(),expect(i).toHaveBeenCalled(),
expect(f).not.toBeResolved(),expect(l).not.toBeResolved(),u.resolve("ccc"),t(),expect(o).toHaveBeenCalled
(),expect(o.mostRecentCall.args).toEqual(["ccc"])})),it("passes the specified 'self' argument as 'this'"
,function(){var n={},r;e.resolve({fun:function(){r=this}},null,null,n),t(),expect(r).toBe(n)}),it("rejects missing dependencies but does not fail synchronously"
,function(){var n=e.resolve({fun:function(e){}});expect(n).not.toBeResolved(),t(),expect(resolvedError
(n)).toMatch(/unknown provider/i)}),it("propagates exceptions thrown by the functions as a rejection"
,function(){var n=e.resolve({fun:function(){throw"i want cake"}});expect(n).not.toBeResolved(),t(),expect
(resolvedError(n)).toBe("i want cake")}),it("propagates errors from a parent resolve",function(){var n=
["the cake is a lie"],r=e.resolve({foo:function(){throw n}}),i=e.resolve({bar:function(){42}},r);t(),
expect(resolvedError(r)).toBe(n),expect(resolvedError(i)).toBe(n)}),it("does not invoke any functions if the parent resolve has already failed"
,function(){var n=e.resolve({foo:function(){throw"oops"}});t(),expect(n).toBeResolved();var r=jasmine
.createSpy("a"),i=e.resolve({a:[r]},n);t(),expect(resolvedError(i)).toBeDefined(),expect(r).not.toHaveBeenCalled
()}),it("does not invoke any more functions after a failure",inject(function(n){var r=n.defer(),i=jasmine
.createSpy("a").andReturn(r.promise),s=n.defer(),o=jasmine.createSpy("c").andReturn(s.promise),u=n.defer
(),a=jasmine.createSpy("d").andReturn(u.promise),f=e.resolve({a:["c",i],c:[o],d:[a]});u.reject("dontlikeit"
),t(),expect(resolvedError(f)).toBeDefined(),s.resolve("ccc"),t(),expect(i).not.toHaveBeenCalled()}))
,it("does not invoke any more functions after a parent failure",inject(function(n){var r=n.defer(),i=
jasmine.createSpy("a").andReturn(r.promise),s=n.defer(),o=jasmine.createSpy("c").andReturn(s.promise)
,u=n.defer(),a=jasmine.createSpy("d").andReturn(u.promise),f=e.resolve({c:[o],d:[a]}),l=e.resolve({a:
["c",i]},f);u.reject("dontlikeit"),t(),expect(resolvedError(f)).toBeDefined(),expect(resolvedError(l)
).toBeDefined(),s.resolve("ccc"),t(),expect(i).not.toHaveBeenCalled()}))}),describe(".study()",function(
){it("returns a resolver function",function(){expect(typeof e.study({})).toBe("function")}),it("refuses cyclic dependencies"
,function(){var t=jasmine.createSpy("a"),n=jasmine.createSpy("b");expect(caught(function(){e.study({a
:["b",t],b:["a",n]})})).toMatch(/cyclic/i),expect(t).not.toHaveBeenCalled(),expect(n).not.toHaveBeenCalled
()}),it("does not call the injectables",function(){var t=jasmine.createSpy("a"),n=jasmine.createSpy("b"
);e.study({a:["b",t],b:[n]}),expect(t).not.toHaveBeenCalled(),expect(n).not.toHaveBeenCalled()}),it("returns a function that can be used multiple times"
,function(){var t=[],n=e.study({a:["what",function(e){t.push("a: "+e)}]});n({what:"1"}),expect(t).toEqual
(["a: 1"]),n({what:"hi"}),expect(t).toEqual(["a: 1","a: hi"])}),it("resolves values from string factory names"
,function(){var n,r=e.study({foo:"Foo"})().then(function(e){n=e.foo});t(),expect(n).toBe("Working")})
})});